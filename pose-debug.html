<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å§¿æ€æ£€æµ‹è°ƒè¯•é¡µé¢</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .video-container {
            position: relative;
            margin: 20px 0;
        }
        #videoCanvas {
            border: 2px solid #333;
            border-radius: 8px;
            max-width: 100%;
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .debug-info {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¯ å§¿æ€æ£€æµ‹è°ƒè¯•é¡µé¢</h1>
        
        <div class="status info" id="status">
            å‡†å¤‡å°±ç»ª - ç‚¹å‡»å¯ç”¨æ‘„åƒå¤´å¼€å§‹æµ‹è¯•
        </div>

        <div class="controls">
            <button class="btn-primary" id="enableCameraBtn">å¯ç”¨æ‘„åƒå¤´</button>
            <button class="btn-success" id="startDetectionBtn" disabled>å¼€å§‹æ£€æµ‹</button>
            <button class="btn-danger" id="stopDetectionBtn" disabled>åœæ­¢æ£€æµ‹</button>
            <button class="btn-secondary" id="toggleSkeletonBtn">åˆ‡æ¢éª¨éª¼æ˜¾ç¤º</button>
            <button class="btn-warning" id="clearConsoleBtn">æ¸…ç©ºæ§åˆ¶å°</button>
            <button class="btn-warning" id="tryTensorFlowBtn" disabled>å°è¯•TensorFlow.js</button>
            <button class="btn-secondary" id="toggleConsoleOutputBtn">åˆ‡æ¢æ§åˆ¶å°è¾“å‡º</button>
            <button class="btn-secondary" id="toggleLabelsBtn">åˆ‡æ¢å…³é”®ç‚¹æ ‡ç­¾</button>
        </div>

        <div class="video-container">
            <canvas id="videoCanvas" width="640" height="480"></canvas>
        </div>

        <div class="debug-info" id="debugInfo">ç­‰å¾…è°ƒè¯•ä¿¡æ¯...</div>
    </div>

    <!-- å¼•å…¥å¿…è¦çš„åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0/dist/pose-detection.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

    <script>
        class PoseDebugger {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.poseNet = null;
                this.poses = [];
                this.isDetecting = false;
                this.showSkeleton = true;

                // æ€§èƒ½æ§åˆ¶
                this.showConsoleOutput = false; // é»˜è®¤å…³é—­æ§åˆ¶å°è¾“å‡º
                this.showLabels = false; // é»˜è®¤å…³é—­æ ‡ç­¾
                this.frameSkip = 0; // è·³å¸§è®¡æ•°å™¨
                this.lastFrameTime = 0;
                this.targetFPS = 15; // é™åˆ¶æœ€å¤§FPS

                this.init();
            }

            init() {
                this.canvas = document.getElementById('videoCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.setupEventListeners();
                this.log('è°ƒè¯•å™¨åˆå§‹åŒ–å®Œæˆ');
            }

            setupEventListeners() {
                document.getElementById('enableCameraBtn').addEventListener('click', () => this.enableCamera());
                document.getElementById('startDetectionBtn').addEventListener('click', () => this.startDetection());
                document.getElementById('stopDetectionBtn').addEventListener('click', () => this.stopDetection());
                document.getElementById('toggleSkeletonBtn').addEventListener('click', () => this.toggleSkeleton());
                document.getElementById('clearConsoleBtn').addEventListener('click', () => this.clearConsole());
                document.getElementById('tryTensorFlowBtn').addEventListener('click', () => this.tryTensorFlowPose());
                document.getElementById('toggleConsoleOutputBtn').addEventListener('click', () => this.toggleConsoleOutput());
                document.getElementById('toggleLabelsBtn').addEventListener('click', () => this.toggleLabels());
            }

            async enableCamera() {
                try {
                    this.updateStatus('æ­£åœ¨å¯ç”¨æ‘„åƒå¤´...', 'info');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 }
                    });

                    this.video = document.createElement('video');
                    this.video.srcObject = stream;
                    this.video.width = 640;
                    this.video.height = 480;
                    this.video.autoplay = true;
                    this.video.muted = true;

                    this.video.addEventListener('loadeddata', () => {
                        this.log('è§†é¢‘æ•°æ®åŠ è½½å®Œæˆ');
                        this.log(`è§†é¢‘å°ºå¯¸: ${this.video.videoWidth}x${this.video.videoHeight}`);
                        this.log(`è§†é¢‘å°±ç»ªçŠ¶æ€: ${this.video.readyState}`);
                        this.updateStatus('æ‘„åƒå¤´å·²å¯ç”¨ - å¯ä»¥å¼€å§‹æ£€æµ‹', 'success');
                        document.getElementById('enableCameraBtn').disabled = true;
                        document.getElementById('startDetectionBtn').disabled = false;
                        document.getElementById('tryTensorFlowBtn').disabled = false;
                    });

                    this.video.addEventListener('playing', () => {
                        this.log('è§†é¢‘å¼€å§‹æ’­æ”¾');
                        // åœ¨è§†é¢‘çœŸæ­£å¼€å§‹æ’­æ”¾æ—¶å¯åŠ¨é¢„è§ˆ
                        setTimeout(() => {
                            this.startPreview();
                        }, 200);
                    });

                    // å¼ºåˆ¶æ’­æ”¾è§†é¢‘
                    setTimeout(() => {
                        this.video.play().then(() => {
                            this.log('âœ… è§†é¢‘æ’­æ”¾å‘½ä»¤æ‰§è¡ŒæˆåŠŸ');
                        }).catch(err => {
                            this.log('âŒ è§†é¢‘æ’­æ”¾å¤±è´¥: ' + err.message);
                        });
                    }, 100);

                    this.video.addEventListener('loadedmetadata', () => {
                        this.log('è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ');
                    });

                    this.video.addEventListener('canplay', () => {
                        this.log('è§†é¢‘å¯ä»¥æ’­æ”¾');
                    });

                    this.video.addEventListener('playing', () => {
                        this.log('è§†é¢‘å¼€å§‹æ’­æ”¾');
                    });

                } catch (error) {
                    this.log('æ‘„åƒå¤´å¯ç”¨å¤±è´¥: ' + error.message);
                    this.updateStatus('æ‘„åƒå¤´å¯ç”¨å¤±è´¥: ' + error.message, 'error');
                }
            }

            startPreview() {
                this.log('å¼€å§‹é¢„è§ˆæ¨¡å¼');
                this.log(`Canvaså°ºå¯¸: ${this.canvas.width}x${this.canvas.height}`);
                this.log(`è§†é¢‘å°ºå¯¸: ${this.video.videoWidth}x${this.video.videoHeight}`);
                this.log(`è§†é¢‘å°±ç»ªçŠ¶æ€: ${this.video.readyState}`);

                let frameCount = 0;

                const drawPreview = () => {
                    if (this.video && this.video.readyState >= 2 && !this.isDetecting) {
                        try {
                            // æ¸…é™¤ç”»å¸ƒ
                            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                            // ç›´æ¥ç»˜åˆ¶è§†é¢‘å¸§ï¼ˆä¸é•œåƒï¼‰
                            this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);

                            // ç»˜åˆ¶æµ‹è¯•æ ‡è®°ç¡®è®¤ç»˜åˆ¶å¾ªç¯å·¥ä½œ
                            this.ctx.fillStyle = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.arc(50, 50, 10, 0, 2 * Math.PI);
                            this.ctx.fill();

                            frameCount++;
                            if (frameCount === 1) {
                                this.log('âœ… é¦–å¸§é¢„è§ˆç»˜åˆ¶æˆåŠŸ');
                            } else if (frameCount === 60) {
                                this.log(`âœ… é¢„è§ˆæ­£å¸¸è¿è¡Œï¼Œå·²ç»˜åˆ¶${frameCount}å¸§`);
                            }
                        } catch (error) {
                            this.log('âŒ é¢„è§ˆç»˜åˆ¶é”™è¯¯: ' + error.message);
                        }
                    } else if (frameCount < 5) {
                        this.log(`âš ï¸ é¢„è§ˆæ¡ä»¶æ£€æŸ¥: video=${!!this.video}, readyState=${this.video?.readyState}, detecting=${this.isDetecting}`);
                    }

                    if (!this.isDetecting) {
                        requestAnimationFrame(drawPreview);
                    }
                };
                drawPreview();
            }

            async startDetection() {
                try {
                    this.updateStatus('æ­£åœ¨åŠ è½½PoseNetæ¨¡å‹...', 'info');
                    this.log('å¼€å§‹åˆå§‹åŒ–PoseNet...');

                    // æ£€æŸ¥ml5ç‰ˆæœ¬å’Œå¯ç”¨æ–¹æ³•
                    this.log('ml5ç‰ˆæœ¬: ' + (ml5.version || 'unknown'));
                    this.log('ml5.poseNetå¯ç”¨: ' + (typeof ml5.poseNet !== 'undefined'));

                    // æ£€æŸ¥è§†é¢‘çŠ¶æ€
                    this.log(`è§†é¢‘çŠ¶æ€æ£€æŸ¥: readyState=${this.video.readyState}, videoWidth=${this.video.videoWidth}, videoHeight=${this.video.videoHeight}`);

                    if (this.video.readyState < 2) {
                        throw new Error('è§†é¢‘è¿˜æœªå‡†å¤‡å¥½ï¼Œæ— æ³•åˆå§‹åŒ–PoseNet');
                    }

                    // å¦‚æœml5.poseNetä¸å¯ç”¨ï¼Œç›´æ¥ä½¿ç”¨TensorFlow.js
                    if (typeof ml5.poseNet === 'undefined') {
                        this.log('âš ï¸ ml5.poseNetä¸å¯ç”¨ï¼Œåˆ‡æ¢åˆ°TensorFlow.jsæ–¹æ³•');
                        await this.tryTensorFlowPose();
                        return;
                    }

                    // å¼ºåˆ¶ä½¿ç”¨CPUåç«¯
                    await tf.setBackend('cpu');
                    this.log('TensorFlowåç«¯: ' + tf.getBackend());

                    // å°è¯•ä¸åŒçš„PoseNetåˆå§‹åŒ–æ–¹æ³•
                    this.log('å°è¯•åˆå§‹åŒ–PoseNet...');

                    // æ–¹æ³•1: ç®€åŒ–é…ç½®
                    this.poseNet = await ml5.poseNet(this.video, {
                        architecture: 'MobileNetV1',
                        imageScaleFactor: 0.3,
                        outputStride: 16,
                        flipHorizontal: false,
                        minConfidence: 0.1,
                        maxPoseDetections: 1,
                        scoreThreshold: 0.1,
                        detectionType: 'single'
                    });

                    this.log('PoseNetå¯¹è±¡åˆ›å»ºæˆåŠŸ: ' + (this.poseNet !== null));

                    // æ·»åŠ è°ƒè¯•å›è°ƒ
                    this.poseNet.on('pose', (results) => {
                        console.log('ğŸ” PoseNetå›è°ƒè§¦å‘ï¼Œç»“æœ:', results);
                        this.poses = results;

                        if (results && results.length > 0) {
                            // é¡µé¢æ—¥å¿—ï¼ˆåªè®°å½•ä¸€æ¬¡ï¼‰
                            if (!this.firstPoseLogged) {
                                this.log(`âœ… æ£€æµ‹åˆ° ${results.length} ä¸ªå§¿æ€`);
                                this.log('å§¿æ€æ•°æ®ç»“æ„:');
                                this.log(JSON.stringify(results[0], null, 2));
                                if (results[0].pose && results[0].pose.keypoints) {
                                    this.log(`å…³é”®ç‚¹æ•°é‡: ${results[0].pose.keypoints.length}`);
                                    this.log('ç¬¬ä¸€ä¸ªå…³é”®ç‚¹: ' + JSON.stringify(results[0].pose.keypoints[0], null, 2));
                                }
                                this.firstPoseLogged = true;
                            }

                            // æ§åˆ¶å°è¯¦ç»†è¾“å‡ºï¼ˆå¯æ§åˆ¶ï¼‰
                            if (this.showConsoleOutput) {
                                console.group('ğŸ¯ PoseNetå®æ—¶æ£€æµ‹ç»“æœ');
                                console.log('æ—¶é—´æˆ³:', new Date().toLocaleTimeString());
                                console.log('æ£€æµ‹åˆ°çš„å§¿æ€æ•°é‡:', results.length);

                                results.forEach((result, index) => {
                                    console.group(`å§¿æ€ ${index + 1}`);
                                    console.log('æ•´ä½“ç½®ä¿¡åº¦:', Math.round(result.pose.score * 100) / 100);
                                    console.log('å…³é”®ç‚¹æ•°é‡:', result.pose.keypoints.length);

                                    // è¾“å‡ºæ‰€æœ‰å…³é”®ç‚¹çš„è¡¨æ ¼
                                    console.table(result.pose.keypoints.map(kp => ({
                                        éƒ¨ä½: kp.part,
                                        Xåæ ‡: Math.round(kp.position.x),
                                        Yåæ ‡: Math.round(kp.position.y),
                                        ç½®ä¿¡åº¦: Math.round(kp.score * 100) / 100,
                                        å¯è§: kp.score > 0.1 ? 'âœ…' : 'âŒ'
                                    })));

                                    // ç»Ÿè®¡é«˜ç½®ä¿¡åº¦å…³é”®ç‚¹
                                    const highConfidencePoints = result.pose.keypoints.filter(kp => kp.score > 0.1);
                                    console.log(`å¯è§å…³é”®ç‚¹: ${highConfidencePoints.length}/${result.pose.keypoints.length}`);

                                    // è¾“å‡ºå…³é”®éƒ¨ä½çš„åæ ‡
                                    const keyParts = ['nose', 'leftEye', 'rightEye', 'leftWrist', 'rightWrist'];
                                    const keyPartData = {};
                                    keyParts.forEach(part => {
                                        const point = result.pose.keypoints.find(kp => kp.part === part);
                                        if (point && point.score > 0.1) {
                                            keyPartData[part] = `(${Math.round(point.position.x)}, ${Math.round(point.position.y)})`;
                                        }
                                    });
                                    if (Object.keys(keyPartData).length > 0) {
                                        console.log('å…³é”®éƒ¨ä½åæ ‡:', keyPartData);
                                    }

                                    console.groupEnd();
                                });

                                console.groupEnd();
                            }

                        } else {
                            console.log('âš ï¸ PoseNetå›è°ƒè§¦å‘ä½†æ— å§¿æ€æ•°æ®ï¼Œresults:', results);
                            if (!this.noPoseLogged) {
                                this.log('âš ï¸ æš‚æœªæ£€æµ‹åˆ°å§¿æ€');
                                this.noPoseLogged = true;
                            }
                        }
                    });

                    // æ·»åŠ é”™è¯¯å¤„ç†
                    this.poseNet.on('error', (error) => {
                        console.error('PoseNeté”™è¯¯:', error);
                        this.log('PoseNeté”™è¯¯: ' + error.message);
                    });

                    // æµ‹è¯•æ‰‹åŠ¨æ£€æµ‹
                    setTimeout(() => {
                        this.log('å°è¯•æ‰‹åŠ¨æ£€æµ‹...');
                        this.testManualDetection();
                    }, 2000);

                    this.isDetecting = true;
                    this.startDrawLoop();
                    
                    this.updateStatus('å§¿æ€æ£€æµ‹å·²å¯åŠ¨', 'success');
                    document.getElementById('startDetectionBtn').disabled = true;
                    document.getElementById('stopDetectionBtn').disabled = false;
                    
                    this.log('PoseNetåˆå§‹åŒ–å®Œæˆï¼Œå¼€å§‹æ£€æµ‹');

                } catch (error) {
                    this.log('PoseNetåˆå§‹åŒ–å¤±è´¥: ' + error.message);
                    this.updateStatus('æ£€æµ‹å¯åŠ¨å¤±è´¥: ' + error.message, 'error');
                }
            }

            startDrawLoop() {
                const draw = (currentTime) => {
                    if (!this.isDetecting) return;

                    // FPSé™åˆ¶ - å‡å°‘ç»˜åˆ¶é¢‘ç‡
                    if (currentTime - this.lastFrameTime < 1000 / this.targetFPS) {
                        requestAnimationFrame(draw);
                        return;
                    }
                    this.lastFrameTime = currentTime;

                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                    // ç»˜åˆ¶è§†é¢‘å¸§
                    this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);

                    // ç»˜åˆ¶å§¿æ€ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                    if (this.poses.length > 0) {
                        this.drawPoseOptimized(this.poses[0]);
                    }

                    requestAnimationFrame(draw);
                };
                draw(performance.now());
            }

            drawPoseOptimized(pose) {
                if (!pose.pose || !pose.pose.keypoints) return;

                const keypoints = pose.pose.keypoints;

                // åªç»˜åˆ¶å…³é”®ç‚¹ï¼Œä¸ç»˜åˆ¶æ ‡ç­¾ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
                this.ctx.fillStyle = '#ff0000';
                keypoints.forEach((keypoint) => {
                    if (keypoint.score > 0.5) {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            keypoint.position.x,
                            keypoint.position.y,
                            6, 0, 2 * Math.PI  // ç¨å°çš„å…³é”®ç‚¹
                        );
                        this.ctx.fill();

                        // å¯é€‰ï¼šç»˜åˆ¶æ ‡ç­¾
                        if (this.showLabels) {
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = '10px Arial';
                            this.ctx.fillText(
                                keypoint.part,
                                keypoint.position.x + 8,
                                keypoint.position.y - 8
                            );
                            this.ctx.fillStyle = '#ff0000';
                        }
                    }
                });

                // å¯é€‰ï¼šç»˜åˆ¶éª¨æ¶
                if (this.showSkeleton) {
                    this.drawSkeletonOptimized(keypoints);
                }
            }

            // ä¿ç•™åŸå§‹ç»˜åˆ¶å‡½æ•°ç”¨äºè°ƒè¯•
            drawPose(pose) {
                if (!pose.pose || !pose.pose.keypoints) {
                    this.log('âš ï¸ å§¿æ€æ•°æ®ç»“æ„é”™è¯¯');
                    return;
                }

                const keypoints = pose.pose.keypoints;

                if (!this.drawPoseLogged) {
                    this.log(`ğŸ¨ å¼€å§‹ç»˜åˆ¶å§¿æ€ï¼Œå…³é”®ç‚¹æ•°é‡: ${keypoints.length}`);
                    this.log('å…³é”®ç‚¹ç¤ºä¾‹: ' + JSON.stringify(keypoints[0], null, 2));
                    this.drawPoseLogged = true;
                }

                // ç»˜åˆ¶å…³é”®ç‚¹
                this.ctx.fillStyle = '#ff0000';
                let visiblePoints = 0;
                keypoints.forEach((keypoint, index) => {
                    if (keypoint.score > 0.5) {
                        visiblePoints++;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            keypoint.position.x,
                            keypoint.position.y,
                            8, 0, 2 * Math.PI
                        );
                        this.ctx.fill();

                        // ç»˜åˆ¶å…³é”®ç‚¹æ ‡ç­¾
                        if (this.showLabels) {
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = '12px Arial';
                            this.ctx.fillText(
                                keypoint.part,
                                keypoint.position.x + 10,
                                keypoint.position.y - 10
                            );
                            this.ctx.fillStyle = '#ff0000';
                        }
                    }
                });

                if (!this.visiblePointsLogged) {
                    this.log(`ğŸ‘ï¸ å¯è§å…³é”®ç‚¹æ•°é‡: ${visiblePoints}/${keypoints.length}`);
                    this.visiblePointsLogged = true;
                }

                // ç»˜åˆ¶éª¨æ¶
                if (this.showSkeleton) {
                    this.drawSkeleton(keypoints);
                }
            }

            drawSkeletonOptimized(keypoints) {
                const connections = [
                    [0, 1], [0, 2], [1, 3], [2, 4], // å¤´éƒ¨
                    [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // æ‰‹è‡‚
                    [5, 11], [6, 12], [11, 12], // èº¯å¹²
                    [11, 13], [13, 15], [12, 14], [14, 16] // è…¿éƒ¨
                ];

                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;  // ç¨ç»†çš„çº¿æ¡

                connections.forEach(([startIdx, endIdx]) => {
                    const startPoint = keypoints[startIdx];
                    const endPoint = keypoints[endIdx];

                    if (startPoint && endPoint && startPoint.score > 0.5 && endPoint.score > 0.5) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(startPoint.position.x, startPoint.position.y);
                        this.ctx.lineTo(endPoint.position.x, endPoint.position.y);
                        this.ctx.stroke();
                    }
                });
            }

            drawSkeleton(keypoints) {
                const connections = [
                    [0, 1], [0, 2], [1, 3], [2, 4], // å¤´éƒ¨
                    [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // æ‰‹è‡‚
                    [5, 11], [6, 12], [11, 12], // èº¯å¹²
                    [11, 13], [13, 15], [12, 14], [14, 16] // è…¿éƒ¨
                ];

                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 3;

                let drawnConnections = 0;
                connections.forEach(([startIdx, endIdx]) => {
                    const startPoint = keypoints[startIdx];
                    const endPoint = keypoints[endIdx];

                    if (startPoint && endPoint && startPoint.score > 0.5 && endPoint.score > 0.5) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(startPoint.position.x, startPoint.position.y);
                        this.ctx.lineTo(endPoint.position.x, endPoint.position.y);
                        this.ctx.stroke();
                        drawnConnections++;
                    }
                });

                if (!this.skeletonLogged) {
                    this.log(`ğŸ¦´ ç»˜åˆ¶éª¨æ¶è¿æ¥: ${drawnConnections}/${connections.length}`);
                    this.skeletonLogged = true;
                }
            }

            stopDetection() {
                this.isDetecting = false;
                this.updateStatus('æ£€æµ‹å·²åœæ­¢', 'info');
                document.getElementById('startDetectionBtn').disabled = false;
                document.getElementById('stopDetectionBtn').disabled = true;
                this.startPreview();
                this.log('æ£€æµ‹å·²åœæ­¢');
            }

            toggleSkeleton() {
                this.showSkeleton = !this.showSkeleton;
                this.log('éª¨éª¼æ˜¾ç¤º: ' + (this.showSkeleton ? 'å¼€å¯' : 'å…³é—­'));
            }

            clearConsole() {
                console.clear();
                this.log('ğŸ§¹ æ§åˆ¶å°å·²æ¸…ç©º');
            }

            toggleConsoleOutput() {
                this.showConsoleOutput = !this.showConsoleOutput;
                const btn = document.getElementById('toggleConsoleOutputBtn');
                btn.textContent = this.showConsoleOutput ? 'å…³é—­æ§åˆ¶å°è¾“å‡º' : 'å¼€å¯æ§åˆ¶å°è¾“å‡º';
                this.log(`æ§åˆ¶å°è¾“å‡º: ${this.showConsoleOutput ? 'å¼€å¯' : 'å…³é—­'}`);
            }

            toggleLabels() {
                this.showLabels = !this.showLabels;
                const btn = document.getElementById('toggleLabelsBtn');
                btn.textContent = this.showLabels ? 'éšè—å…³é”®ç‚¹æ ‡ç­¾' : 'æ˜¾ç¤ºå…³é”®ç‚¹æ ‡ç­¾';
                this.log(`å…³é”®ç‚¹æ ‡ç­¾: ${this.showLabels ? 'æ˜¾ç¤º' : 'éšè—'}`);
            }

            async testManualDetection() {
                try {
                    this.log('æ‰§è¡Œæ‰‹åŠ¨æ£€æµ‹æµ‹è¯•...');

                    if (!this.poseNet) {
                        this.log('âŒ PoseNetå¯¹è±¡ä¸å­˜åœ¨');
                        return;
                    }

                    // å°è¯•æ‰‹åŠ¨è°ƒç”¨æ£€æµ‹
                    const results = await this.poseNet.singlePose(this.video);
                    console.log('æ‰‹åŠ¨æ£€æµ‹ç»“æœ:', results);
                    this.log('æ‰‹åŠ¨æ£€æµ‹å®Œæˆï¼Œç»“æœ: ' + JSON.stringify(results, null, 2));

                } catch (error) {
                    console.error('æ‰‹åŠ¨æ£€æµ‹å¤±è´¥:', error);
                    this.log('æ‰‹åŠ¨æ£€æµ‹å¤±è´¥: ' + error.message);

                    // å¦‚æœml5 PoseNetå¤±è´¥ï¼Œå°è¯•MediaPipe
                    this.log('å°è¯•åˆ‡æ¢åˆ°MediaPipe Pose...');
                    this.initMediaPipePose();
                }
            }

            async initMediaPipePose() {
                try {
                    this.log('åˆå§‹åŒ–MediaPipe Pose...');

                    // åŠ¨æ€åŠ è½½MediaPipe
                    if (typeof window.MediaPipe === 'undefined') {
                        await this.loadMediaPipeScript();
                    }

                    // è¿™é‡Œä¼šå®ç°MediaPipeçš„åˆå§‹åŒ–
                    this.log('MediaPipeè„šæœ¬åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');

                } catch (error) {
                    console.error('MediaPipeåˆå§‹åŒ–å¤±è´¥:', error);
                    this.log('MediaPipeåˆå§‹åŒ–å¤±è´¥: ' + error.message);
                }
            }

            async loadMediaPipeScript() {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            async tryTensorFlowPose() {
                try {
                    this.log('å°è¯•ä½¿ç”¨ TensorFlow.js PoseNet...');

                    if (!this.video || this.video.readyState < 2) {
                        this.log('âŒ è§†é¢‘æœªå‡†å¤‡å¥½');
                        return;
                    }

                    // åœæ­¢å½“å‰æ£€æµ‹
                    this.stopDetection();

                    // åˆå§‹åŒ–TensorFlow.js PoseNet
                    const detector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.PoseNet,
                        {
                            architecture: 'MobileNetV1',
                            outputStride: 16,
                            inputResolution: { width: 640, height: 480 },
                            multiplier: 0.75,
                            quantBytes: 2
                        }
                    );

                    this.log('âœ… TensorFlow.js PoseNet åˆå§‹åŒ–æˆåŠŸ');
                    this.tensorFlowDetector = detector;
                    this.isDetecting = true;
                    this.startTensorFlowDetection();

                    document.getElementById('tryTensorFlowBtn').disabled = true;
                    document.getElementById('stopDetectionBtn').disabled = false;
                    this.updateStatus('TensorFlow.js å§¿æ€æ£€æµ‹å·²å¯åŠ¨', 'success');

                } catch (error) {
                    this.log('âŒ TensorFlow.js åˆå§‹åŒ–å¤±è´¥: ' + error.message);
                    console.error('TensorFlow.js é”™è¯¯:', error);
                }
            }

            async startTensorFlowDetection() {
                const detect = async () => {
                    if (!this.isDetecting || !this.tensorFlowDetector) return;

                    try {
                        const poses = await this.tensorFlowDetector.estimatePoses(this.video);

                        if (poses && poses.length > 0) {
                            console.group('ğŸ¯ TensorFlow.js PoseNet æ£€æµ‹ç»“æœ');
                            console.log('æ—¶é—´æˆ³:', new Date().toLocaleTimeString());
                            console.log('æ£€æµ‹åˆ°çš„å§¿æ€æ•°é‡:', poses.length);

                            poses.forEach((pose, index) => {
                                console.group(`å§¿æ€ ${index + 1}`);
                                console.log('æ•´ä½“ç½®ä¿¡åº¦:', Math.round(pose.score * 100) / 100);
                                console.log('å…³é”®ç‚¹æ•°é‡:', pose.keypoints.length);

                                console.table(pose.keypoints.map(kp => ({
                                    éƒ¨ä½: kp.name,
                                    Xåæ ‡: Math.round(kp.x),
                                    Yåæ ‡: Math.round(kp.y),
                                    ç½®ä¿¡åº¦: Math.round(kp.score * 100) / 100,
                                    å¯è§: kp.score > 0.1 ? 'âœ…' : 'âŒ'
                                })));

                                console.groupEnd();
                            });

                            console.groupEnd();

                            // æ›´æ–°posesæ•°æ®ç”¨äºç»˜åˆ¶
                            this.poses = poses.map(pose => ({
                                pose: {
                                    keypoints: pose.keypoints.map(kp => ({
                                        part: kp.name,
                                        position: { x: kp.x, y: kp.y },
                                        score: kp.score
                                    })),
                                    score: pose.score
                                }
                            }));
                        }

                        requestAnimationFrame(detect);

                    } catch (error) {
                        this.log('âŒ TensorFlow.js æ£€æµ‹é”™è¯¯: ' + error.message);
                        console.error('TensorFlow.js æ£€æµ‹é”™è¯¯:', error);
                    }
                };

                detect();
            }

            updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            log(message) {
                const debugEl = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();
                debugEl.textContent += `[${timestamp}] ${message}\n`;
                debugEl.scrollTop = debugEl.scrollHeight;
                console.log(message);
            }
        }

        // å¯åŠ¨è°ƒè¯•å™¨
        window.addEventListener('load', () => {
            new PoseDebugger();
        });
    </script>
</body>
</html>
